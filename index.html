<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Animated Gradient</title>
  <style>
    body { margin: 0; overflow: hidden; background: #ffffff; }
    canvas { display: block; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(6.2, -3.3, 1.0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enabled = false;

    const group = new THREE.Group();
    group.position.set(5.7, 1.9, -5.0);
    group.rotation.set(-0.09, -0.26, -0.85);
    group.scale.set(1.59, 1.45, 2.80);
    scene.add(group);

    const clock = new THREE.Clock();

    const loader = new THREE.TextureLoader();
    const texture = loader.load('/Textures/texture1.png', (tex) => {
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
    });

    const makeMaterial = () => new THREE.ShaderMaterial({
      vertexShader: `
        varying vec2 vUv;
        uniform float uTime;

        void main() {
          vUv = uv;
          vec3 pos = position;
          pos.y += 0.01 * sin(uv.x * 10.0 + uTime * 2.0);
          pos.y += 0.1 * sin(uv.y * 4.0 - uTime * 1.5);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uTexture;
        uniform float uTime;

        void main() {
          vec2 uv = vUv;
          uv += vec2(0.01 * sin(uTime * 0.5), 0.01 * cos(uTime * 0.4));
          uv.x += sin(uv.y * 40.0 + uTime * 2.0) * 0.01;
          uv.y += cos(uv.x * 35.0 + uTime * 2.5) * 0.01;
          vec4 tex = texture2D(uTexture, uv);
          float shimmer = 0.02 * sin((uv.x + uv.y) * 25.0 + uTime * 3.0);
          vec3 shimmerColor = tex.rgb + vec3(shimmer);
          vec3 color = mix(tex.rgb, shimmerColor, 0.9);
          gl_FragColor = vec4(clamp(color, 0.0, 1.0), tex.a);
        }
      `,
      uniforms: {
        uTime: { value: 0.0 },
        uTexture: { value: texture }
      },
      side: THREE.DoubleSide,
      transparent: false,
      alphaTest: 0.01,
      depthWrite: false,
      depthTest: true,
      blending: THREE.NormalBlending,
      polygonOffset: true,
      polygonOffsetFactor: -1,
      polygonOffsetUnits: -1
    });

    const createCurve = (radius, offset, phase) => {
      const points = [];
      for (let i = 0; i < 500; i++) {
        const t = i / 499;
        const taper = 0.5 + 0.5 * Math.sin(t * Math.PI);
        const wave = Math.sin(t * Math.PI * 2) * 0.5 * taper;
        const angle = t * Math.PI * 4 + phase;
        const x = Math.sin(angle) * radius * taper + offset.x + t * 5.0;
        const y = -t * 10.0 + wave;
        const z = Math.cos(angle) * radius * taper + offset.z + t * 5.0;
        points.push(new THREE.Vector3(x, y, z));
      }
      return new THREE.CatmullRomCurve3(points);
    };

    const createRibbon = (curve, width, segments, material) => {
      const geometry = new THREE.BufferGeometry();
      const positions = [], uvs = [], indices = [];

      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const point = curve.getPoint(t);
        const tangent = curve.getTangent(t);
        const normal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(width / 2);
        const left = point.clone().add(normal);
        const right = point.clone().sub(normal);
        uvs.push(0, t);
        uvs.push(1, t);
        positions.push(...left.toArray(), ...right.toArray());
      }

      for (let i = 0; i < segments; i++) {
        const idx = i * 2;
        indices.push(idx, idx + 1, idx + 2);
        indices.push(idx + 1, idx + 3, idx + 2);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      return new THREE.Mesh(geometry, material);
    };

    const materials = [makeMaterial(), makeMaterial(), makeMaterial()];
    const offsets = [
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(0.04, 0, -0.04),
      new THREE.Vector3(-0.04, 0, 0.04)
    ];
    const phases = [0, Math.PI * 2 / 3, Math.PI * 4 / 3];

    for (let i = 0; i < 3; i++) {
      const curve = createCurve(0.2, offsets[i], phases[i]);
      const mesh = createRibbon(curve, 0.6, 500, materials[i]);
      mesh.renderOrder = i;
      group.add(mesh);
    }

    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.DirectionalLight(0xffdddd, 0.5);
    light.position.set(0, 10, 10);
    scene.add(light);

    function animate() {
      const time = clock.getElapsedTime();
      materials.forEach(mat => mat.uniforms.uTime.value = time);
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
