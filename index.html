<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Animated Braid</title>
  <style>
    body { margin: 0; overflow: hidden; background: #ffffff; }
    canvas { display: block; }
  </style>

  <!-- Import map to use ES modules directly from CDN -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Create a scene
    const scene = new THREE.Scene();

    // Create and configure camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(6.2, -3.3, 1.0); // Initial camera position

    // Create renderer and attach to DOM
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, precision: 'highp' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0); // Transparent background
    renderer.sortObjects = true;
    document.body.appendChild(renderer.domElement);

    // Camera controls (disabled for now)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enableRotate = false;
    controls.enableZoom = false;
    controls.enablePan = false;
    controls.enabled = false;

    // Create group to hold the animated meshes
    const group = new THREE.Group();
    group.position.set(5.7, 1.9, -5.0);
    group.rotation.set(-0.09, -0.26, -0.85);
    group.scale.set(1.59, 1.45, 2.80);
    scene.add(group);

    // Add ambient light
    scene.add(new THREE.AmbientLight(0xff1b6b, 0.5));

    const clock = new THREE.Clock(); // For animation timing

    // Load hair texture and build material with shader
    const loader = new THREE.TextureLoader();
    loader.load('/Textures/haircolor1.png', texture => {
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.flipY = false;
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      texture.minFilter = THREE.LinearMipMapLinearFilter;
      texture.magFilter = THREE.LinearFilter;

      // Shader material with subtle inner waving effect
      const createMaterial = () => new THREE.ShaderMaterial({
        vertexShader: `
          varying vec2 vUv;
          uniform float uTime;
          void main() {
            vUv = uv;
            vec3 pos = position;
            float pulse = 1.0 + 0.015 * sin(uTime); // Subtle vertical waving
            pos.y *= pulse;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform sampler2D uTexture;
          uniform float uTime;
          void main() {
            vec2 uv = vUv;
            uv += 0.0005 * vec2(sin(uTime), cos(uTime)); // Gentle drift
            uv.y += 0.02 * sin(uTime * 0.2); // Vertical subtle flow

            vec4 tex = texture2D(uTexture, vec2(uv.y, uv.x)); // Use vertical texture

            // Create edge fading
            float fadeX = smoothstep(0.0, 0.1, uv.x) * (1.0 - smoothstep(0.9, 1.0, uv.x));
            float fadeY = smoothstep(0.0, 0.1, uv.y) * (1.0 - smoothstep(0.9, 1.0, uv.y));
            float edgeFade = fadeX * fadeY;

            // Add gradient overlay
            vec3 fadeColor = vec3(0.1, 0.1, 0.15);
            vec3 gradientTint = mix(vec3(0.9, 0.85, 1.0), vec3(0.1, 0.1, 0.2), vUv.y);
            vec3 tintedTexture = mix(tex.rgb, gradientTint, 0.1);
            vec3 base = mix(fadeColor, tintedTexture, edgeFade);

            // Highlight shimmer
            float highlight = 0.1 * sin(vUv.y * 20.0 + uTime * 2.0);
            vec3 finalColor = base + highlight;

            gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), tex.a * edgeFade * 0.85);
          }
        `,
        uniforms: {
          uTime: { value: 0.0 },
          uTexture: { value: texture }
        },
        side: THREE.BackSide, // Invert for ribbon look
        transparent: false,
        depthWrite: false,
        depthTest: true,
        blending: THREE.NormalBlending,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1,
      });

      // Creates a wavy braid curve path
      const braidCurve = (radius, offset, phase) => {
        const points = [];
        for (let i = 0; i < 300; i++) {
          const t = i / 299;
          const angle = t * Math.PI * 6 + phase;
          const x = Math.sin(angle) * radius + offset.x + t * 5.0;
          const y = -t * 10.0;
          const z = Math.cos(angle) * radius + offset.z + t * 5.0;
          points.push(new THREE.Vector3(x, y, z));
        }
        return new THREE.CatmullRomCurve3(points);
      };

      // Offsets and phases for multiple strands
      const pathRadius = 0.2;
      const offsets = [
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0.04, 0, -0.04),
        new THREE.Vector3(-0.04, 0, 0.04)
      ];
      const phases = [0, Math.PI * 2 / 3, Math.PI * 4 / 3];

      // Create and add 3 ribbon strands to the group
      for (let i = 0; i < 3; i++) {
        const curve = braidCurve(pathRadius, offsets[i], phases[i]);
        const geometry = new THREE.TubeGeometry(curve, 300, 0.2, 32, false);
        const mesh = new THREE.Mesh(geometry, createMaterial());
        mesh.renderOrder = i;
        group.add(mesh);
      }

      // Start the animation loop
      animate();
    });

    // Animation loop
    function animate() {
      const time = clock.getElapsedTime();

      // Update time uniform for all shaders
      group.children.forEach(mesh => {
        if (mesh.material.uniforms?.uTime) {
          mesh.material.uniforms.uTime.value = time;
        }
      });

      controls.update(); // even if disabled, doesn't harm
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Make canvas responsive
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
